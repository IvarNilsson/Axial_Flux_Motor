#include <Arduino.h>
#include <esp_task_wdt.h>

#define POTENTIOMETER_PIN 33

#define DAC_CH1 25

#define pwm_pin1 32
#define pwm_pin2 26
#define pwm_pin3 27

// generat table using
// https://daycounter.com/Calculators/Sine-Generator-Calculator.phtml
#define Num_Samples 240  //  number of dample of signal
#define MaxWaveTypes 2   // types of wave (sin=0, tri=1)

TaskHandle_t Task1;
TaskHandle_t Task2;

double sin1;
double sin2;
double sin3;

double tri;

double amplitude_sin = 1;
double amplitude_tri = 1;

double phase1 = 0;
double phase2 = Num_Samples / 3;
double phase3 = Num_Samples * 2 / 3;
double freq_sin = 0;
double freq_tri = 1;  // mellan 0 & 1

double ma = amplitude_sin / amplitude_tri;  // Amplitude modulation ratio!
// Vab = Va - Vb
// Vbc = Vb - Vc
// Vca = Vc - Va

int analogValue = 0;
int old_analogValue = 0;

unsigned long t_test1 = 0;  // for tests
unsigned long t_test2 = 0;  // for tests
int count1 = 0;             // for tests
int count2 = 0;             // for tests
boolean live1 = true;       // for tests
boolean live2 = true;       // for tests
double cycle1 = 0;

int t = 0;

static byte WaveFormTable[MaxWaveTypes][Num_Samples] = {
    // Sin wave
    {0x3c, 0x3e, 0x3f, 0x41, 0x42, 0x44, 0x45, 0x47, 0x48, 0x4a, 0x4c, 0x4d,
     0x4f, 0x50, 0x52, 0x53, 0x54, 0x56, 0x57, 0x59, 0x5a, 0x5b, 0x5d, 0x5e,
     0x5f, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
     0x6d, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x71, 0x72, 0x73, 0x73, 0x74, 0x75,
     0x75, 0x76, 0x76, 0x76, 0x77, 0x77, 0x77, 0x77, 0x78, 0x78, 0x78, 0x78,
     0x78, 0x78, 0x78, 0x78, 0x78, 0x77, 0x77, 0x77, 0x77, 0x76, 0x76, 0x76,
     0x75, 0x75, 0x74, 0x73, 0x73, 0x72, 0x71, 0x71, 0x70, 0x6f, 0x6e, 0x6d,
     0x6d, 0x6c, 0x6b, 0x6a, 0x69, 0x68, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61,
     0x5f, 0x5e, 0x5d, 0x5b, 0x5a, 0x59, 0x57, 0x56, 0x54, 0x53, 0x52, 0x50,
     0x4f, 0x4d, 0x4c, 0x4a, 0x48, 0x47, 0x45, 0x44, 0x42, 0x41, 0x3f, 0x3e,
     0x3c, 0x3a, 0x39, 0x37, 0x36, 0x34, 0x33, 0x31, 0x30, 0x2e, 0x2c, 0x2b,
     0x29, 0x28, 0x26, 0x25, 0x24, 0x22, 0x21, 0x1f, 0x1e, 0x1d, 0x1b, 0x1a,
     0x19, 0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x10, 0xf,  0xe,  0xd,  0xc,
     0xb,  0xb,  0xa,  0x9,  0x8,  0x7,  0x7,  0x6,  0x5,  0x5,  0x4,  0x3,
     0x3,  0x2,  0x2,  0x2,  0x1,  0x1,  0x1,  0x1,  0x0,  0x0,  0x0,  0x0,
     0x0,  0x0,  0x0,  0x0,  0x0,  0x1,  0x1,  0x1,  0x1,  0x2,  0x2,  0x2,
     0x3,  0x3,  0x4,  0x5,  0x5,  0x6,  0x7,  0x7,  0x8,  0x9,  0xa,  0xb,
     0xb,  0xc,  0xd,  0xe,  0xf,  0x10, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
     0x19, 0x1a, 0x1b, 0x1d, 0x1e, 0x1f, 0x21, 0x22, 0x24, 0x25, 0x26, 0x28,
     0x29, 0x2b, 0x2c, 0x2e, 0x30, 0x31, 0x33, 0x34, 0x36, 0x37, 0x39, 0x3a},
    // Triangular wave table
    {0x1,  0x2,  0x3,  0x4,  0x5,  0x6,  0x7,  0x8,  0x9,  0xa,  0xb,  0xc,
     0xd,  0xe,  0xf,  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
     0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
     0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30,
     0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c,
     0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48,
     0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54,
     0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60,
     0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c,
     0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
     0x77, 0x76, 0x75, 0x74, 0x73, 0x72, 0x71, 0x70, 0x6f, 0x6e, 0x6d, 0x6c,
     0x6b, 0x6a, 0x69, 0x68, 0x67, 0x66, 0x65, 0x64, 0x63, 0x62, 0x61, 0x60,
     0x5f, 0x5e, 0x5d, 0x5c, 0x5b, 0x5a, 0x59, 0x58, 0x57, 0x56, 0x55, 0x54,
     0x53, 0x52, 0x51, 0x50, 0x4f, 0x4e, 0x4d, 0x4c, 0x4b, 0x4a, 0x49, 0x48,
     0x47, 0x46, 0x45, 0x44, 0x43, 0x42, 0x41, 0x40, 0x3f, 0x3e, 0x3d, 0x3c,
     0x3b, 0x3a, 0x39, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, 0x31, 0x30,
     0x2f, 0x2e, 0x2d, 0x2c, 0x2b, 0x2a, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24,
     0x23, 0x22, 0x21, 0x20, 0x1f, 0x1e, 0x1d, 0x1c, 0x1b, 0x1a, 0x19, 0x18,
     0x17, 0x16, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0xf,  0xe,  0xd,  0xc,
     0xb,  0xa,  0x9,  0x8,  0x7,  0x6,  0x5,  0x4,  0x3,  0x2,  0x1,  0x0}};

void setup() {
    Serial.begin(115200);
    pinMode(pwm_pin1, OUTPUT);
    pinMode(pwm_pin2, OUTPUT);
    pinMode(pwm_pin3, OUTPUT);

    Serial.println("________________________");
    Serial.print("CPU freq: ");
    Serial.print(getCpuFrequencyMhz());
    Serial.println(" MHz");
    Serial.print("Abp freq: ");
    Serial.print(getApbFrequency() / 1000000);
    Serial.println(" MHz");
    Serial.println("________________________");

    xTaskCreatePinnedToCore(
        Task1code, /* Task function. */
        "Task1",   /* name of task. */
        8192,     /* Stack size of task */ //10000 standard
        NULL,      /* parameter of the task */
        1,         /* priority of the task */
        &Task1,    /* Task handle to keep track of created task */
        0);        /* pin task to core 0 */
    delay(500);

    xTaskCreatePinnedToCore(
        Task2code, /* Task function. */
        "Task2",   /* name of task. */
        8192,     /* Stack size of task */
        NULL,      /* parameter of the task */
        1,         /* priority of the task */
        &Task2,    /* Task handle to keep track of created task */
        1);        /* pin task to core 1 */
    delay(500);
}

void Task1code(void* pvParameters) {
    Serial.print("Task1 running on core ");
    Serial.println(xPortGetCoreID());
    Serial.print("Task1: ");
    Serial.println("Waves + DigitaWrite");
    Serial.println("________________________");

    esp_task_wdt_init(30, false);

    for (;;) {
        // vTaskDelay(1); // if I disabled watchdog correctly this should not be
        // a problem that we never sleep :)

        // optimize the i<500 probelby possible to increase
        // jump some samples to midigate the delay
        // for (uint16_t i = 0; i < 500; i++) {

        // test case for running 1 000 000 cycles
        t++;
        if (t == 1000000) {  // for tests
            t_test1 = millis();
        } else if (t == 2000000) {
            t_test1 = millis() - t_test1;
            live1 = false;
        }

        if (!live1) {  // for tests
            Serial.println("________________________");
            Serial.print("delta t (ms) per 1000000 cykler= ");
            Serial.println(t_test1);
            Serial.print("t per cycle (ms)= ");
            cycle1 = ((double)t_test1) / ((double)1000000, 5);
            Serial.println(cycle1);
            Serial.print("frequency triangle wave (kHz)");
            Serial.println(1/(cycle1*240*1000), 5);
            Serial.println("________________________");
            live1 = true;
        }

        sin1 = sample_sin(t, amplitude_sin, freq_sin, phase1);
        sin2 = sample_sin(t, amplitude_sin, freq_sin, phase2);
        sin3 = sample_sin(t, amplitude_sin, freq_sin, phase3);

        tri = sample_tri(t, amplitude_tri, freq_tri);

        /*
              Serial.println("________________________");
              Serial.print(sin1);
              Serial.print(", ");
              Serial.print(sin2);
              Serial.print(", ");
              Serial.println(sin3);
              Serial.println(tri);
        */

        if (sin1 > tri) {
            digitalWrite(pwm_pin1, 1);
        } else {
            digitalWrite(pwm_pin1, 0);
        }

        if (sin2 > tri) {
            digitalWrite(pwm_pin2, 1);
        } else {
            digitalWrite(pwm_pin2, 0);
        }

        if (sin3 > tri) {
            digitalWrite(pwm_pin3, 1);
        } else {
            digitalWrite(pwm_pin3, 0);
        }
        //}
    }
}

void Task2code(void* pvParameters) {
    Serial.print("Task2 running on core ");
    Serial.println(xPortGetCoreID());
    Serial.print("Task2: ");
    Serial.println("AnalogRead");
    Serial.println("________________________");
    for (;;) {
        vTaskDelay(10);
        analogValue = analogRead(POTENTIOMETER_PIN);

        if (analogValue < 200) {
            freq_sin = 0.000005 * 200;
        } else {
            freq_sin = 0.000005 * analogValue;
        }

        // Serial.print("sin freq: ");
        // Serial.println(freq_sin * massa saker för att få den till typ Hz/kHz)
        vTaskDelay(1000);
    }
}

double sample_sin(int t, double amplitude, double freq, double phase) {
    t = (int)((t * freq) + phase) % Num_Samples;
    return WaveFormTable[0][(int)t] * amplitude;
}

double sample_tri(int t, double amplitude, double freq) {
    t = (int)(t * freq) % Num_Samples;
    return WaveFormTable[1][(int)t] * amplitude;
}

void loop() { vTaskDelay(portMAX_DELAY); }
